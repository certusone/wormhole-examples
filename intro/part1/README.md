# Intro to Wormhole - Part 1

## Setup

Start a [minimal_devnet](../../../minimal_devnet/)

Deploy the EVM contracts

```bash
cd ethereum
npm ci
npm run migrate
npm run register
```

Run the UI

```bash
cd ui
npm ci
npm run typechain
npm start
```

# Tech
### Chain side
The Ethereum smart contract is in
`ethereum/contracts/Messenger.sol`
It simply posts received string to the wormhole network
```
    function sendStr(bytes memory str, uint32 nonce) public returns (uint64 sequence) {
        sequence = _wormhole.publishMessage(nonce, str, 1);
        return sequence;
    }
```
`IWormhole.publishMessage` finction is part of wormhole SDK. Last argument is consistency level. It tells Wormhole how many blocks to go before the message is approved (VAA-ed). We use 1 here to get response faster. In production 15 is used.
Wormhole smart contract address on chain is known and is hardcoded into this example.

### Client side
Calling code is in
`ui/src/App.tsx`
`sendClickHandler` is function which sends a string message to the Messenger contract, and then waits for Wormhole to sign VAA generated by Messenger. We then use returned sequence number and our originator chainId to tell Wormhole which VAA we're looking for. Using this data - we then wait and retrieve retrieve VAA from Wormhole using SDK `getSignedVAAWithRetry` call. Now this VAA is signed, and is good to be used on another Wormhole connected chain! That will be done in Part2.
